# 알고리즘

## 자료구조:

삽입과 삭제 2개의 동작으로 구성

### 1. 스택 자료구조:

- 박스쌓기처럼 먼저 들어온 데이터는 나중에 나가는 형식 (선입후출 자료구조)

- Python: 리스트와 append() & pop() 함수 사용해서 스택 자료구조 구현 가능
  - print(리스트명) : 들어온 순서, 왼쪽에서 오른쪽으로 정렬
  - 리스트명[::-1] : 마지막에 들어왔던, 즉 최상단 원소부터 출력가능

### 2. 큐 자료구조 :

- 은행 창고처럼 먼저 들어온 데이터가 먼저 나가는 형식 (선입선출 자료구조)
- Python: 스택자료구조와 달리, 리스트보다 deque(덱) 라이브러리 사용이 더욱 시간 효율적이다

```python
from collections import deque

# deque 라이브러리 사용
queue = deque()

queue.append(1)
queue.append(2)
queue.append(3)
queue.popleft()
queue.append(4)
queue.append(5)
queue.popleft()

print(queue)
=> deque([3, 4, 5])

# 나중에 들어온 원소부터 출력하고 싶다면 .reverse() 메소드 활용
queue.reverse()
print(queue)
=> deque([5, 4, 3])
```



### 3. 우선순위 큐:

- 데이터를 우선순위에 따라 처리(삭제)하고 싶을 때

- 가장 우선순위가 높은 데이터부터 처리함

- 우선순위 큐 구현방법
   1. 리스트 사용 : 삽입 시간은 단순하지만, 리스트를 확인하고 priority를 매번 따져야해서 삭제시간이 N만큼 필요
    2. 힙(heap)자료구조 활용 : 최악의 상황에서도 시간 복잡도O(logN) 유지가능!

| 우선순위 큐 구현방법 | 삽입 시간 | 삭제 시간 |
| -------------------- | --------- | --------- |
| 리스트               | O(1)      | O(N)      |
| 힙                   | O(logN)   | O(logN)   |



#### 힙(heap)의 특징:

- 완전 이진 트리 자료구조(Complete Binary Tree)이다.
  - 루트 노드부터 시작해서 왼쪽 자식노드, 오른쪽 자식 노드 순서대로 데이터가 차례대로 생성되는 트리
- 힙에서는 Root node를 항상 먼저 제거
- 최소 힙: 루트 노드가 가장 작은 값을 지님. 서브 트리의 루트 노드도 가장 작은 값을 가지고. 그래서 값이 작은 데이터가 우선적으로 제거됨
- 최대 힙 : 루트 노드가 가장 큰 값을 지님
- Heapify() : 힙을 구성하기 위한 함수
  - 사용자가 트리 자료구조를 생성했는데 만약 이 구조가 최소힙/최대힙의 조건을 만족하지 못하고 있고(예를 들어 루트 노드의 숫자가 자식 노드보다 크거나 작다던지) 힙 성질(조건)을 만족하는 트리를 바꾸고 싶을 때 사용한다.
  - Min-Heapify() : 최소힙 구성
    - 노드 추가 : 상향식으로 진행. 부모 노드로 거슬러 올라가면서 최소or최대 조건을 check하는데  부모보다 자신의 값이 더 작으면 위치를 교체함
    - 루트 노드 삭제: 가장 마지막 노드가 가장 상위 루트 노드로 이동하고, 그 다음에 하향식으로 Heapify()를 진행 (더 작은 자식 노드로)

  - Python은 기본적으로 오름차순 정렬




### 4. 트리 자료구조:

트리 : 계층적인 구조 표현 가능한 자료구조.

- 루트 노드: 부모가 없는 최상위 노드
- 단말 노드(leaf node): 자식이 없는 노드

- 크기 : 노드 개수

- 깊이 : 루트 노드부터의 거리. 루트노드의 깊이는 0 그 아래 노드는 깊이1, 그 아래 노드는 깊이2 ...

- 높이 : 위의 깊이 중 최대값.

- 차수(degree): 각 노드의 (자식 방향)간선 개수, 즉 자식의 개수가 몇개인지

:heavy_check_mark: 트리 크기가 N이면 간선개수는 N-1임



#### 이진 탐색 트리(Binary search tree)

- 이진 탐색이 동작될 수 있게끔 고안된 자료구조

- 각 노드 내의 값의 크기 순서는 : 왼쪽 자식 노드 < 부모 노드 < 오른쪽 자식 노드

  <img src="Day11 (220110).assets/image-20220110172326955.png" alt="image-20220110172326955" style="zoom:50%;" />

만약 내가 찾고자 하는 원소가 7이라면

1. 루트 노드부터 방문: 7은 12보다 작으니 왼쪽으로 이동
2. 2번째 루트 노드와 비교: 7은 3보다 크니 오른쪽 선택



#### 트리의 순회(Tree Traversal):

- 트리 자료구조에 포함된 노드를 특정한 방법으로 다 하나씩 방문

- 대표적인 트리 순회 방법들:

  <img src="Day11 (220110).assets/image-20220110172836597.png" alt="image-20220110172836597" style="zoom:50%;" />

1. 전위 순회(pre-order traverse): 루트 먼저, 왼쪽, 오른쪽

   A-B-D-E-C-F-G

2. 중위 순회(in-order traverse): 왼쪽 , 루트, 오른쪽

​		D-B-E-A-F-C-G

3. 후위 순회(post-order traverse): 왼쪽, 오른쪽, 루트. 루트가 젤 마지막이란거지

   D-E-B-F-G-C-A



#### 바이너리 인덱스 트리(BIT)/펜윅 트리(Fenwick Tree)

데이터 업데이트가 빈번히 일어나고 구간합(Interval Sum)도 여러번 구하는 일이 생긴다면?

- 2진법 인덱스 구조를 활용해 구간 합 문제를 효과적으로 해결해 줄 수 있는 자료구조인 BIT 활용!

- 0이 아닌 마지막 비트 찾는법: K & -K (여기서 &는 비트연산)
  -  만약 이 연산 수행했을 때 0이 나오면 0밖에 없다, 1이면 첫번째 자리, 2이면 둘째자리, 4이면 셋째자리, 8이면 넷째자리

![image-20220110180033205](Day11 (220110).assets/image-20220110180033205.png)

- 데이터 변경:

  - 예를 들어 숫자 7이 변경되었음. 숫자 7은 0이 아닌 마지막 비트가 1개이므로 7 + 1을 한 8을 찾아가면, 8은 0이 아닌 마지막 비트가 8개이므로 8+8을 한 16을 찾아간다. 즉 숫자 7의 정보를 갖고있는 인덱스만 값을 변경하는것

- 누적합(Prefix Sum):

  - 예를들어, 숫자 10이라면 0이 아닌 마지막 비트가 2개이므로 10 - 2를 한 8을 찾아가고, 8은 8개이므로 여기서 끝난다. 결과적으로 1부터 10까지의 누적합을 계산 가능하게 된다

  

## 정렬 알고리즘:

상황에 따라 다양한 정렬 알고리즘이 적용된다.

### 1. 선택 정렬:

- 처리되지 않은 데이터 중 가장 작은 데이터를 선택해서 맨 앞에 있는 데이터와 바꿈

- 마지막은 바꿀 데이터가 없기때문에 끝난다

- 선형 탐색을 매번 반복하는 것이 선택 정렬이다

- 시간 복잡도: N번만큼 가장 작은 수를 찾아서 맨 앞으로 보내야해야함. O(N^2)



### 2. 삽입 정렬:

- 처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입
- 구현 난이도는 선택 정렬보다 조금 더 높지만, 더 효율적임
- 맨 첫번째 원소는 정렬되었다고 가정한 후 그 다음 원소를 확인해서 정렬된 원소들의 어느 곳(앞?뒤?)에 위치시킬지 정한다



# Python

### sys.stdin.readline:

- input()대신 sys.stdin.readline()을 사용하는 이유:
  - 만약 반복문으로 긴 줄을 입력 받아야할 때 input()으로 입력을 받는다면 시간 초과 발생이 가능하다.
  - 한줄 단위로 입력받는다는 특징 때문에 개행문자(\n)가 같이 입력받아짐
  - 입력한 한 라인을 iterable한 컨테이너에 저장
  - std stands for standard input

```python
import sys
# 입력값이 한 줄 일때 문자열로 저장:
a = int(sys.stdin.readline()) 

# 입력값이 여러개일 때 하나씩(띄어쓰기 포함) 출력:
for i in sys.stdin.readline():
    print(i)

# 입력값을 리스트로 저장 (개행문자 빠짐)
list(map(int,sys.stdin.readline().split()))
```

