# 통계적 추론

> 표본을 뽑아서 평균을 낸다면 이것은 얼마나 모평균과 비슷할까?

- 대수의 법칙(평균과 관련) : 모평균과 표본평균의 차이는 매우작다 표본의 크기가 크면 커질수록 확률적으로 모평균과 수렴해짐
- 중심극한정리(분포와 관련): 임의의 모집단에서 크기가 N인 표본을 추출할 때 크기가 커진다면 X바의 분포는 정규분포모양이 나옴



## 추정

- 추정량은 1. 불편성과 2. 일치성을 가지는 것이 바람직하다

- 불편성 : 기대값이 추측하기 원하는 모수가 되는 성질 (예를 들어 표본평균이 모이고 모여서모평균이 되고 싶어하는 성질)
- 일치성 : 표본 크기(n)을 키우면 키울수록 모수에 수렴하는 성질

--> 두 성질을 가지고 있는 추정량을 좋은 추정량이라고 생각한다

-  표본의 수가 많을 수록 표본평균의 평균은 모평균과 일치해지지만, 분산은 수가 늘어나도 표본평균만큼 모분산과 일치해지진 않는다. 분산은 n이 아니라 n-1로 나눠주면 모분산과 유사해진다.

- 그래서 계산식 쓸 때는 
  - s_var = np.var(sample, axis=1,ddof=1) / s_var.mean() 한 값은 모분산과 비슷해짐
  - ddof를 1로하면 자유도가 n-1이란 뜻이다
  - 
  - 만약에 n을 100백만 개로 한다면 : np.var(random.choice(scores, 1e6),ddof=1)) 한다면 모분산과 굉장히 유사한 값이 나온다
- 정리 : 서로 독립인 표본들(x1, x2, x3 ..)이 기대값이 모평균(뮤), 분산(시그마제곱)이 모분산인 확률분포를 따를 때, 표본평균(엑스바)와 불편분산(자유도가 n-1, 시그마제곱)에 대해서 불편성과 일치성을 가진 아주 좋은 추정량이 된다



### 1. 점추정

- 추정량 : 모수를 추정하는데 이용하는 통계량 예) 표준평균
- 추정치 :실제 얻어진 값, 표본을 이용해서 계산된 추정량의 값
- 표준오차 : 추정량이 모수에 얼마나 가까운지를 나타내기 위해서. 추정량의 표준편차
- 추정량은 반드시 표준오차와 함께 제시



- 모평균의 점추정:
  - 표본에 해당하는 표준편차 / 루트N
  - 우리가 실제로 모분산은 구하기 힘들잖아..그래서 표본분산을 대체해서 구함

- 하지만 점추정은 위험한 부분이 많음 왜냐하면 편향된 표본을 추출해버리는 경우가 될 가능성이 높다 이럴 때 구간추정이 유용하다~



### 2. 구간추정

- 신뢰구간 : 모수를 추정하는데 이용되는 구간. 좁을수록 좋겠지
- 신뢰 수준 : 신뢰구간이 모수를 포함할 확률



- 모집단이 정규분포를 따르거나 표본의 크기가 충분히 크다면 :
- 1-알파는 모평균이 존재할 확률
- 실제로는 모집단의 표준편차를 모르는게 대부분이니까 실제로는 T분포를 많이 사용한다
- 자유도가 커지면 정규분포와 가까워짐



1. 정규분포를 따르고 구간추정 모평균 구하기

- 표본 데이터를 z값으로 변환을 한다. 어떻게 z값으로 변환하냐? 

- z값 : 편차/모표준편차

- 표본표준편차 = 모표준편차(시그마)/루트N

- 하한선 : 엑스바 - 표본표준편차 * k <z < 상한선 :  엑스바 + 표본표준편차 * k 

- 여기서 k는  .isf(알파/2) 한 값



2. 정규분포를 따르고, 모평균은 모를 때 모분산 구하기

- 카이제곱분포(확률분포의 일종) 사용



3. 정규분포를 따르고, 모분산을 모를때 모평균 구하기

- 모표준편차로 빼고 더했던거를 표본표준편차로 빼고 더한다
- z값: 편차/표본표준편차(불편편차)
- 대신 구간구할 때 n이 아니라 n-1
- 그리고 norm()이 아니라 t(df = n-1)

```python
data = [520, 498, 481, 512, 515, 542, 520, 518, 527, 526]

# 정규분포를 따르고, 모분산을 아는 경우 : 
d_mean = np.mean(data)
d_var = np.var(data)
alpha = 0.05
n = 10
rv = stats.norm() # 이거 인자없이

lcl= d_mean-rv.isf(alpha/2)*np.sqrt(d_var/n)
ucl= d_mean+rv.isf(alpha/2)*np.sqrt(d_var/n)

# 정규분포를 따르고, 모분산을 모르는 경우 : t-분포 사용
d_mean = np.mean(data)
d_var = np.var(data)
alpha = 0.05
n = 10
rv = stats.t(df=n-1)

lcl= d_mean-rv.isf(alpha/2)*np.sqrt(d_var/n)
ucl= d_mean+rv.isf(alpha/2)*np.sqrt(d_var/n)
```



## 가설검정

> 시각화는 주관적인 해석이 들어간다는 단점이 있는데, 객관적인 지표를 제시하고 싶을 때 가설검정을 실행한다

- 대립가설 : 주장하고 싶은 가설로 효과가 있다, 관계가 있다 등
- 귀무가설 : 반박하고 싶은 가설
- 귀무가설을 기각한다는 것은 대립가설이 옳고 귀무가설이 틀리다는 주장이다
- 귀무가설 채택 기준 : 드문 값을 우연히 얻은게 아니라 의미가 있는 값이라고 생각했을 때



- 검정통계량(z) 계산 방법: 편차/sqrt(표준편차/n)

- 검정통계량 : `z= (s.mean - data.mean()/np.sqrt(s_div/n))` 

- p-value와 유의수준을 비교한다
- p-value : 가설검정 판단 기준으로 p.value와 유의수준을 비교함으로써 가설검정을 한다.
- p-value : rv.cdf(Z)
  - 만약 p-value가 유의수준 보다 작다면 귀무가설을 기각한다 (여기서 말하는 p-value는 너비를 뜻함)



- 데이터 타입, 변수의 개수, 정규성, 등분산성 등 여러 요인에 따라 쓰는 검정 방법이 다르다 :

| 변수의 개수 | 데이터 타입                       | 검정방법들                                       |                                                            |
| ----------- | --------------------------------- | ------------------------------------------------ | ---------------------------------------------------------- |
| 단일변수    | 연속형                            | 정규성                                           | One-sample T-TEST ( 하나의 표본과 전체 집단의 평균을 비교) |
|             | 범주형                            | 비율검정 (비율에 유의미한 차이가 있는가?)        |                                                            |
| 다변수(X/Y) | 범주형, 연속형 (남/여의 성적차이) | 정규성 0: two-sample T-TEST(두집단비교)          | 등분산검정(분산을 비교하는 검정)                           |
|             |                                   | 정규성 X: 비모수적 검정                          |                                                            |
|             | 범주형,범주형                     | 카이스퀘어 검정 (두 변수가 서로 독립이냐 아니냐) |                                                            |
|             | 연속형,범주형                     | 로지스틱분석                                     |                                                            |
|             | 연속형, 연속형                    | 상관분석                                         | 회귀분석                                                   |

#### 단일변수 : 

1) 정규성 검정

- 정규성을 띠는지 안띠는지 확인
- 대립가설 : 정규성을 띠지 않는다

`stats.normaltest(df.열이름)` ==> 통계량과 p-value를 출력하는데 p-value를 유의수준(alpha)비교해서 더 작게 나온다면 기각한다(즉 정규성을 띠지 않는다)

- 만약 normaltest를 하는데 df에 nan값이 있으면 오류가 뜨므로 끝에 dropna() 쓰면 오류가 해결된다



2. one sample T-Test (일표본 평균검정):

- 하나의 표본의 평균과 전체데이터의 평균(모평균)과 차이점이 차이점이 있는지 확인. 가령 내 아들은 수능점수가 80인데 다른 학생들의 평균에 속할까?

`stats.ttest_1samp(df.열이름, 모평균)`==> p-value와 유의수준을 비교한다



#### 다변수:

1. 등분산검정(Levene test):

- 두 집단의 분산에 차이가 있는지 확인한다
- 대립가설 : 두 분산에는 차이가 있다

`stats.levene(df.열이름, df2.열이름)`==> 마찬가지로 p-value와 유의수준을 비교해서 만약 p-value가 더 낮게나온다면 등분산성을 만족하지 못한다

2. two sample T-Test(이표본 평균검정)

- 등분산성을 띠지 않을 때 시행하므로, __등분산성 검사가 선행되어서 기각이 되었을 때만 가능하다__
- 대립가설 : 두 표본간에 평균차이가 있다

`stats.ttest_ind(df.열이름, df2.열이름)` 

- 여기서 ind는 independent를 뜻한다

3. chai square Test

- 대립가설 : 두 표본간에 연관이 있다(independent 하지않다)
- contingency table이 먼저 필요하다. 이 테이블은 두 데이터의 빈도수를 계산한다

`pd.crosstable(df1.열이름, df2.열이름)` ==> contingency table생성

`stats.chi2_contingency(cross테이블)` ==> 4개의 인수 반환, 순서대로 1) 카이통계량 2)p-value 3) 자유도 4) array.기대값

- 우리는 p-value만 확인하면 된다. 
- array기대값은 데이터를 기반으로 모수를 추정한 값이다

4. 번외

- 만약에, two sample T-TEST에서 등분산성을 띤다면?
- 다 똑같은데 ttest_ind()마지막에 equal_var=True라고 작성해주면 끝



#### 비정규성을 띠는 데이터:

- 비모수적 검정